<!DOCTYPE html>
<!-- 14иня2023
Удалось визуализировать колладу. 
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="data:image/gif;base64,R0lGODlhEAAQAOYAAP7WAPXOCZZ9VVZIVUE3VVBDVZF6U/HLDP/uAKdPWIoAVAAAAAAAZOTANf/wAP/eAP3TAP3VAP/aAP/8AMsAN/8AAC4ARgAAKaqPQf/tAP/YAP7TAMrTM/QACaUAUwAALN+8Lv7VAP/mALydQbcBegAAS/zVHf/1AM93LtAALSkA1QAA/wAABRANQcurSfPNC/DRDQwU8QAAEgAADQEBRVNGqwAA/gAAIyEc3QAA/QAAJ/fRB39xfgAAF//7AMB2PnUAiAAABAAAKHRiXbaZP//pAMGMPGQA0gAAJcKjQv/gALnARLwBVwAACox2Vf/bAPr4A88AL1MATQAAC2lYVv/yALspR+QAJQAAFIRwZf/lAP/XAOO8G4NeWEA2QDAoQDsyQG1bQc2tKefDFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQEewABACwAAAAAEAAQAAAHqYAAgoMANTg7hIQSDyInMCsrPD5FSk+DCBMcIygxkCs/RktQVQABCRQdFSmQOStAFRVRVlwCCrAVKis2rSu3V10DCxYeJJ6eR0xSWF4EC84LLDI3Oj1BzwtfBdfb22AG3OALYQcM4dcXYgANF+YLU1mCDhgf4U1UDoIPGSAl3EhOGbQIgqAhg4kW14QkyaAEgqAIG0JkcDHj2ZATTzZsSQTgBY1nRAiNCQQAOw==">


  
  <title>Kastle</title>
  <style>
  /* прога урожденная k/!frontend/zamok22/20/9.html */
  /* [YOUTUBE="https://www.youtube.com/watch?v=jQjVMWOgzXY"]видео[/YOUTUBE] */
  .palet {display:flex;}
  .palet .color {width:24px; height:24px;background: white;border:1px solid blue;}
.opo{
	background: #FFFFFF;
	padding: 13px;
	margin: auto;
}
.kod {
display: flex;
justify-content: flex-start;
align-items: flex-end;
}
.copybara {
	background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAATCAIAAAAS8MqlAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAEsSURBVDhPnZC9TsMwFIV5RXZ4BF6BjpHYwgQrCxLpEDEQJ6FlohJMaQOoQvyUhZaGspHE8U+55lbErU0j9egosm/O5yN76zsvNrDCTg09Pb/oIdMLbK4Jtp3O5XrSjsE3iqI1ZI2lb5+9x2wuZRzHwIRhSAjRo7qX2iRAUsKiZegiCOxYOoK2KelP2rdjyP2esxCS3e6VBZNSSCG44CDEVLWaCdy6rvtH1thglPWGU5JMvJt3zB2cP+x7d1wIx3GAQa1icCpWMc4Qg4kacg7r2dcMbMEGr9n18CNIxmfLbXsn6e5xf/swgYkF04UYY7xiVVVRCqYlTFYxXb7v123te9V2ZGszDW8AIdVBS1oWpXLejMFvbGt5qm3HejfTiJlqxv4TBuxYozfC8uIHUDp6oFBQcH0AAAAASUVORK5CYII=);
	background-size: cover;
	cursor: pointer;
	width: 27px;
	height: 30px;
	margin-left:-27px;
	margin-bottom:20px;	
} 
.kod article{align-self: flex-start}

#svg{border: 2px solid purple;}
.btn0{border:2px solid purple;
padding:6px;border-radius:40%;}
.btn1{border:2px solid green;
padding:6px;border-radius:40%;}

button{cursor: pointer;
border:1px solid purple;
padding:3px;border-radius:6px;
}
#vvod{width:444px;}
[id^='rok']{display:none;}/* перермещение точек пиалы */
[id^='rok']:checked + * {background-color: cyan;border-radius:0;}
.box{padding: 10px 12px 0;border: 2px solid green;display: inline-block;width: fit-content;border-radius: 8px;background: #ded;}
.x{/*элементы этого класса окрашиваются от клика мышью*/}
  </style>
</head>
<body>
<div class="kod">
	<svg id="svg" width="700" height="415" viewBox="0 0 700 415" fill="none">
	<style type="text/css">
	.rect1, .polygon1 {stroke: blue;}
	.txt1 {font-family: Arial; font-size: 24px; line-height: 0; fill:white;}
	</style>
		<rect x="0" y="0" width="700" height="250" fill="silver" />
	</svg>
	<div class="copybara" onclick="cpy(this.parentElement);" title="Copy"></div>
	
</div>
<br>

<div class="box">
<select id="selen" style="width:440px" onchange="vvod.value=this.value; md=1; main()">
  <option value="a(aa(c)zz)z">a(aa(c)zz)z</option><!-- a(aa(c)zz)z -->
  <option value="a12(c)zzz">a12(c)zzz</option>
  <option value="a12czzz">a12czzz</option>  
  <option value="acz">acz</option>  
  <option value="a(c)z">a(c)z</option> 
  <option value="aacca(cc)zzca(c)zcccccca(c)zcz">aacc(cc)zc(c)cccccc(c)cz</option>  
  <option value="aaa(c)zzz">aaa(c)zzz</option> <!-- a(a(a(c)z)z)z -->
  <option value="a(a(a(c)z)z)z">a(a(a(c)z)z)z</option>  
  <option value="a(a(a(c)z)z-c-a(a(a(c)z)z)z-c-a(a(c)z)z)z">a(a(a(c)z)z-c-a(a(a(c)z)z)z-c-a(a(c)z)z)z</option>  
  <option value="a(c-a(c)z-a(a(c)z)z-a(a(a(c)z)z)z-a(a(a(a(c)z)z)z)z)z">a(c-a(c)z-a(a(c)z)z-a(a(a(c)z)z)z-a(a(a(a(c)z)z)z)z)z</option>  
  <option value="aacadz-aaa3fzzz-a(f)zz(g)zz">aacadz-aaa3fzzz-a(f)zz(g)zz</option>    
  <option value="aca[e4d]zz" selected>aca[e4d]zz</option>  
  
</select><br>  



<input id="vvod" type="text" value="a(c)z">

<button class="btn1" type="button" style="transform:translatey(-13px);" onclick="
ss=vvod.value; 
md=1;
main();
">do</button>
</div>


<button class="btn0" id="btn0" style="d0isplay: none;"
type="button" onclick="
md=0;
main();
">do</button>

<button class="btn2" type="button" onclick="
//ta1.value='';

navigator.clipboard.readText()
	.then(text => {
		ta1.value=text;
		btn0.onclick();
	})
	.catch(err => {
	console.log('Oblomingo flyed pass', err);
	});
">paste</button>


<br><!--  xor 20 xor 1 -->
<textarea id="ta1" rows="20" cols="90" style="color: white; background: #1e154f;"
onclick="this.setAttribute('rows',+this.getAttribute('rows') ^ 20 ^ 2)"
>
&lt;mesh&gt;
        &lt;source id="Cube-mesh-positions"&gt;
          &lt;float_array id="Cube-mesh-positions-array" count="24"&gt;0.5 0.5 -0.5 0.5 -0.5 -0.5 -0.5000001 -0.4999999 -0.5 -0.4999998 0.5000002 -0.5 0.5000002 0.4999997 0.5 0.4999997 -0.5000003 0.5 -0.5000002 -0.4999998 0.5 -0.5 0.5 0.5&lt;/float_array&gt;
          &lt;technique_common&gt;
            &lt;accessor source="#Cube-mesh-positions-array" count="8" stride="3"&gt;
              &lt;param name="X" type="float"/&gt;
              &lt;param name="Y" type="float"/&gt;
              &lt;param name="Z" type="float"/&gt;
            &lt;/accessor&gt;
          &lt;/technique_common&gt;
        &lt;/source&gt;
        &lt;source id="Cube-mesh-normals"&gt;
          &lt;float_array id="Cube-mesh-normals-array" count="36"&gt;0 0 -1 0 0 1 1 -5.66244e-7 -2.38419e-7 0 -1 -2.98023e-7 -1 2.38419e-7 -1.19209e-7 2.08616e-7 1 2.38419e-7 0 0 -1 0 0 1 1 0 3.27826e-7 -4.76837e-7 -1 0 -1 2.08616e-7 -1.49012e-7 2.68221e-7 1 1.78814e-7&lt;/float_array&gt;
          &lt;technique_common&gt;
            &lt;accessor source="#Cube-mesh-normals-array" count="12" stride="3"&gt;
              &lt;param name="X" type="float"/&gt;
              &lt;param name="Y" type="float"/&gt;
              &lt;param name="Z" type="float"/&gt;
            &lt;/accessor&gt;
          &lt;/technique_common&gt;
        &lt;/source&gt;
        &lt;source id="Cube-mesh-map-0"&gt;
          &lt;float_array id="Cube-mesh-map-0-array" count="72"&gt;0.666467 0.6664669 0.3335332 0.666467 0.666467 0.3335332 0.3331337 0.3331335 1.9982e-4 0.3331336 1.9976e-4 1.99879e-4 0.666467 1.9976e-4 0.666467 0.3331335 0.3335332 0.3331335 0.9998003 0.3335331 0.9998003 0.6664669 0.6668666 0.3335331 1.9976e-4 0.9998003 1.9978e-4 0.6668666 0.3331336 0.9998003 0.3331336 0.3335331 0.3331336 0.6664669 1.9986e-4 0.666467 0.3335332 0.666467 0.3335331 0.3335331 0.666467 0.3335332 0.3331335 1.9976e-4 0.3331337 0.3331335 1.9976e-4 1.99879e-4 0.3335334 1.998e-4 0.666467 1.9976e-4 0.3335332 0.3331335 0.9998003 0.6664669 0.6668666 0.666467 0.6668666 0.3335331 1.9978e-4 0.6668666 0.3331335 0.6668666 0.3331336 0.9998003 1.9976e-4 0.3335332 0.3331336 0.3335331 1.9986e-4 0.666467&lt;/float_array&gt;
          &lt;technique_common&gt;
            &lt;accessor source="#Cube-mesh-map-0-array" count="36" stride="2"&gt;
              &lt;param name="S" type="float"/&gt;
              &lt;param name="T" type="float"/&gt;
            &lt;/accessor&gt;
          &lt;/technique_common&gt;
        &lt;/source&gt;
        &lt;vertices id="Cube-mesh-vertices"&gt;
          &lt;input semantic="POSITION" source="#Cube-mesh-positions"/&gt;
        &lt;/vertices&gt;
        &lt;polylist material="Material-material" count="12"&gt;
          &lt;input semantic="VERTEX" source="#Cube-mesh-vertices" offset="0"/&gt;
          &lt;input semantic="NORMAL" source="#Cube-mesh-normals" offset="1"/&gt;
          &lt;input semantic="TEXCOORD" source="#Cube-mesh-map-0" offset="2" set="0"/&gt;
          &lt;vcount&gt;3 3 3 3 3 3 3 3 3 3 3 3 &lt;/vcount&gt;
          &lt;p&gt;0 0 0 1 0 1 3 0 2 4 1 3 7 1 4 6 1 5 0 2 6 4 2 7 5 2 8 1 3 9 5 3 10 2 3 11 2 4 12 6 4 13 3 4 14 4 5 15 0 5 16 3 5 17 1 6 18 2 6 19 3 6 20 5 7 21 4 7 22 6 7 23 1 8 24 0 8 25 5 8 26 5 9 27 6 9 28 2 9 29 6 10 30 7 10 31 3 10 32 7 11 33 4 11 34 3 11 35&lt;/p&gt;
        &lt;/polylist&gt;
      &lt;/mesh&gt;



</textarea>
<textarea id="ta2" rows="3" cols="90" style="d0isplay:none;color: white; background: #1a0e5a;">

</textarea>


<textarea id="cop" rows="1" cols="90" style="position:absolute; left:-9999px; color: white; background: green;" title="используется для копирования">
</textarea>
<br>

<article class="palet" style="d0isplay: none;">
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>
	<div class="color"></div>	
	<div class="color"></div>	
</article>

<h2 id="la" style="font-family: sans-serif"></h2>

<script>
let never='!';//символ никогда не встречаемый в тегах
let ee=0;// счетчик элементов
let md=0; // откуда брать данные 0-из та, 1-из эдита, 2-
  yrr=// модель надписи
	  [{dotx0:419,doty0:246, // начало
	  dotx1:449,doty1:187, // изгиб начала
	  dotx2:469,doty2:142, // изгиб конца
	  dotx3:478,doty3:123, // конец	  
	  dotx4:-2,doty4:-37, // reserved
	  dotx5:38,doty5:-31, // reserved
		txt:'', 
		color:'navy',}
	  ]; 
  let kx='dotx1',ky='doty1';
  let w=0;// курсор текстовых лейблов
  let z=-17;
  let hey=415;// высота svg
let mainColor='white';
const cc=['white','red','black','green','yellow','lime',
'violet','purple','navy','aqua','blue','gold',
'teal','olive','maroon','silver','springgreen','#6c757d','fuchsia'];
document.querySelectorAll('.color').
	forEach((x,i)=>{x.style.background=cc[i]; 
		x.addEventListener('click',(e)=>{mainColor=cc[i];if(false){main();}})
		}); 
/************************************/
let stek4=[]; // рюмашки
let city=1.0;// opacity прозрачность фигур

let off; // смещение композиции к центру
let dx=25;//25 
let dy=-25; // 25
let x11x=0,y11y=hey-15//180;//+50dx  
let s700=900;//1300;//


  
const clr=()=>{ta1.value=""}

function optima(x){// сокращения -------------------------------------------------
/*
в эту трясину может засосать до переполнения стека.
выдача может быть периодическая бесконечная
это как с математической дробью
например 1/3 дает три в периоде (3) отследить легко
период (13) сложнее, если в периоде больше цифр то уж извините.
может следить чтобы, вложенное  было короче внешнего?
 алгоритм  найти минус и от него в обе стороны брать символы и плюсовать их к тестовой строке
 до тех пор пока левая часть не станет равна правой типа 'a(c)z-a(c)z'
при достижении этого все тестовая поддстрока заменяется на '(a(c)z)'
может мешаются ()? позаменить их на чтото нейтральное типа <>?
*/
lenx=x.length;// длина входящего сообщения

const cre=x=>{
	let r = /-+/ig;
	let t, a=[];
	while (t =r.exec(x))a.push(t.index); 
	return a  
	}  

let e,xe,xd,n,i,s3,s4;

let a=cre(x);  //a: array of integer;
for (let i=0; i<a.length; i++){//i
	n=a[i];
	e=''; d='';
	xe=0; xd=0;
	for (let j=1;j<=Math.min(a[i],x.length-a[i]); j++) {//j 
		n--;
		d=d+x[a[i]+j];// правая часть тест-строки
		e=x[a[i]-j]+e;//  левая часть тест-строки
		switch(x[a[i]-j]){
			case 'z': {xe++; break}
			case 'a':
			case '1':
			case '2': {xe--; break}
		   }   
		switch(x[a[i]+j]){
			case 'a':
			case '1':
			case '2': {xd++; break}
			case 'z': {xd--; break}			
			}

		if ((xe<0)||(xd<0)) break;	  
		if ((xe===xd)&&(xd===0)&&(e===d)) {	  
		
		s3=x.substring(0,n); //  от индекса a до индекса b 
		s4=x.substring(n); // от n до конца
		let r=new RegExp("("+e+")(-\\1)+",'g');
		s4=s4.replace(r,'($1)');
		
		if(s4.length<lenx)
			{return s3 + optima(s4)}else{return s3+s4}
		}
	}//j
}//i
return x;
}//func optima	

const obana=(x)=>{//адаптирован под бирки
	let s,k;
	let m=[];
	let a=[...x];
	a.forEach((i,j)=>{
		switch (i)// a(c)dz    a(c)(3)z
			{
			case 'a': m.push(j);break;
			case 'z': k=m.pop();
				let kk;
				for(let t=k+1; t<a.length; t++){kk=t;if(!/[а-я]/.test(a[t]))break}
				let y=x.substring(kk,j);
				// опознание по наличию скобок в содержимом
				// скобок нет - постамент не нужен
				if ((y.indexOf('(')>0)||(y.indexOf(')')<(y.length - 1))||
				((y[0]!=='(')||(y[y.length - 1]!==')')))
				{
				a[k]='A';
				a[j]='Z';
				}
			}//switch
		});
		
	s=a.join('');	
	s=s.replace(/a([а-я]+)\(/g,'<$1');// времено в угловые с постаментом
	s=s.replace(/\)z([а-я]+)/g,'>$1');
	
	s=s.replace(/\(/g,'[');// все оставшиеся это брекеты
	s=s.replace(/\)/g,']');		
	
	s=s.replace(/</g,'(');// угловые в круглые
	s=s.replace(/>/g,')');		
	s=s.toLowerCase();
	return s;
	}

function main(){// отрисовка
let alf="abcdefghijklmnopqrstuvwxyz";
let o={'a':'ф','b':'б','c':'в','d':'г','e':'д','f':'е','g':'ж','h':'з','i':'и','j':'к','k':'л','l':'м','m':'н','n':'п','o':'р','p':'с','q':'т','r':'у','s':'х','t':'ц','u':'ч','v':'ш','w':'щ','x':'э','y':'ю','z':'я','_':'ъ'}
let o2={'ф':'a','б':'b','в':'c','г':'d','д':'e','е':'f','ж':'g','з':'h','и':'i','к':'j','л':'k','м':'l','н':'m','п':'n','р':'o','с':'p','т':'q','у':'r','х':'s','ц':'t','ч':'u','ш':'v','щ':'w','э':'x','ю':'y','я':'z','ъ':'_'}
const birk=(x)=>[...x].map((i,j)=>o[i]).join('');
stek4=[];
/*высушить*/
s=ta1.value;
s=s.replace(/\n/g,never);//в одинарных тегах теперь эти палки делают их неузнаваемыми
s=s.replace(/<!--.*?-->/g,never);//жадность была нежадной 26,04,2023

let d='';

let b=false, pk=false;// купон
for (let i=0; i<s.length; i++){// теги переношу атрибуты нет
	switch (s[i]) {
		case '/':if (b){d=d+'/'}else{pk=true;} break;
		case '<':d=d+'<'; b=true; pk=false;break;
		case '>':d+=(pk)?'/>':'>'; b=false; pk=false;break;
		case ' ':if (b) b=false; pk=false; break;
		case never: pk=false;break;
		default: if (b) d=d+s[i]; pk=false;
	}//switch
}
s=d;

[ ///теги уничтожаемые как мусор
	'<br>','<hr>','<meta>','<!doctype>',
	'<style>','</style>',
	'<title>','</title>',
	'<head>','</head>', 
	'<html>','</html>',
	'<i>','</i>','<b>','</b>',
	'<link>',
	'<strong>','</strong>',
	'<sub>','</sub>','<sup>','</sup>',
	'<tt>','</tt>',
	//'<source>',//одинарные неизвестные теги глушат движок
	// в колабе сурс парный тег, в отличие от хтмл
	'<center>','</center>',
].forEach(x=>{
	let y=new RegExp(x,'g');
	s=s.replace(y,'');
	});

//////////////////////////////////// заглушить
  s=s.replace(/(<sc?ript>.*?<\/sc?ript>)/gi,'');//анти скрипт
  s=s.replace(/(<style>.*?<\/style>)/gi,'');//анти style 
  s=s.replace(/(<svg>.*?<\/svg>)/gi,'<svg>');//анти svg  
  s=s.replace(/(<table>.*?<\/table>)/gi,'<table></table>');//анти table  
  s=s.replace(/(<pre>.*?<\/pre>)/gi,'');//анти pre   
  
  s=s.toLowerCase();
  
  const closeli=x=>{// закрывает незакрытые лишки
	  x=x.replace(/<\/li>/gi,'');
	  x=x.replace(/<li>/gi,'</li><li>');
	  x=x.replace(/(<\/[uo]l>)/gi,'</li>$1'); // </ul> => </li></ul>
	  x=x.replace(/(<[uo]l>)<\/li>/gi,'$1');// <ul></li> => <ul>    
	  return x;
  }  
  s=closeli(s);// закрывает незакрытые лишки
  let sp=['li'], sp2=['b'];
  
  let a;// непарные теги массивом
  let a7=s.match(/<[^\/>]+\/>/g);// непарные теги добываю на месте
  a7=(a7)?a7.map(i=>i.replace(/[<>\/]/g,'')):['img','input','svg'];//
  a7=new Set(a7);
  a=Array.from(a7);
// организую регулярку поиска непарных тегов
let re1=new RegExp('<([^>]+)><\/\1>|'+a.map(i=>'<'+i+'[а-я]+>').join('|'),'i');
let re2=new RegExp('<([^>]+)><\/\1>|'+a.map(i=>'<('+i+'[а-я]+)>').join('|'),'i');  
let re4=new RegExp(a.map(i=>i).join('|'),'i');   
// убираю слеш из непарных тегов 
s=s.replace(/\/>/g,'>');
// окружаю знаками замену   
const f0=(mat,x1,x2)=>{
	if(!(sp.indexOf(x1)+1)){sp.push(x1); sp2.push(alf[sp.length])};

	return ' !'+sp2[sp.indexOf(x1)]+x2+'! ';
};      
let ad=s.split(/([<>\/])/);
ad=ad.map(x=>{if(/[_a-z]/.test(x)){return x+birk(x)}else{return x}}).join('');
s=ad;// рус бирками снабдил
// тег заменил англ буквой с биркой
s=s.replace(/<([^>а-я]+)([а-я]+)><\/\1\2>/ig,f0);


// одинарные
while((re1).test(s)){
	let g=s.match(re2);
	let aw=g.filter((x,i)=>i&&x);
	g=aw[0];
	let u=g.replace(/[а-я]/gi,'');
	let re3=new RegExp('<('+u+')([а-я]+)>','ig');
	s=s.replace(re3,f0);
  }//while


// списки
s=s.replace(/<ul([а-я]+)>/gi,'1$1');
s=s.replace(/<ol([а-я]+)>/gi,'1$1'); 
s=s.replace(/<li([а-я]+)>/gi,'2$1');
// парные
s=s.replace(/(<[^\/а-я]+?)([а-я]+)(>)/gi,' a$2 ');
s=s.replace(/(<\/[^а-я]+?)([а-я]+)(>)/gi,' z$2 ');
// антипробел
s=s.replace(/[<> ]/gi,'');
// убрал невер
let rg=new RegExp(never,'g'); s=s.replace(rg,'');

//
s=s.replace(/z([а-я]+)a([а-я]+)/gi,'z$1-a$2');//отступы меж башнями
s=s.replace(/z([а-я]+)2([а-я]+)/gi,'z$1-2$2');// 
s=s.replace(/z([а-я]+)1([а-я]+)/gi,'z$1-1$2');//
s=s.replace(/a([а-я]+)z([а-я]+)/gi,'3$1');//
s=s.replace(/(b[а-я]+)+/gi,'$1');//c лишками крышками//

//
s=s.replace(/([cdefghijklmnopqrstuvwxy])([а-я]+)(\1\2)+/gi,'$1$2-$1$2');//32 audio сжать в один
//
mc=s.match(/(2[^-\r\n]+)/gi);// разбираюсь с лишками
if (!!mc) mc.forEach(x=>{let y=new RegExp(x+'-'+x,'g'); s=s.replace(y,x)});

ta2.value=s;
//


let sed;
do{
	sed=[...s].map(i=>i).join('');
	s=[...s].map(x=>(x===')')?'>':x).join('');
	s=[...s].map(x=>(x==='(')?'<':x).join('');
	s=optima(s);// сокращения ------------------------------------------------------------------
	s=[...s].map(x=>(x==='>')?')':x).join('');
	s=[...s].map(x=>(x==='<')?'(':x).join('');
	}while(sed!==s);//выход если обработка не изменила строку


//******
s=s.replace(/2([а-я]+)\(/g,'a$1(');
ta2.value+='\n'+s;
s=obana(s);// скобки превратил в брекеты
//
let tv=s.split(/([a-z_\(\)][а-я]+|[\[\]\(\)-])/);//измельчение до отдельных знаков препинания
let tv1=tv.map(i=>i.replace(/[а-я]/gi,'')).filter(i=>i);
let tv2=tv.map(i=>i.replace(/[a-z]/gi,'')).filter(i=>i);
tv2=tv2.map(i=>[...i].map(j=>o2[j]).join(''));//расшифровка бирок
s=s.replace(/([а-я]+)/gi,'');

let tv3=tv1.map((x,i)=>[x,tv2[i]]);  
//***********

tv3=tv3.map(x=>[((re4).test(x[1]))?'4':x[0].replace(/[b-y]/gi,'0'),x[1]]);


//***************************************** отладка 
if (md===1){// брать с эдита
s=vvod.value;
s=s.replace(/2([а-я]+)\(/g,'a$1(');//
//s=obana(s); // отделил скобки от брекетов
tv=s.split('');//измельчение до отдельных знаков препинания
//tv2=tv.map(i=>i.replace(/[a-z]/gi,'')).filter(i=>i);
tv3=tv.map(x=>[x,'']);
tv3=tv3.map(x=>[x[0].replace(/[b-y]/gi,'0'),x[1]]);
}
//******************************************* 
 
console.table(tv3);


  la.innerHTML=s;
  ta2.value+='\n'+s;
  
//////////////////////////////////////draw формирует свг

const svg=document.querySelector('#svg');
svg.setAttribute("width", s700);
svg.setAttribute("viewBox", "0 0 "+s700+" "+hey);

svg.innerHTML=//sq6();// стиль
/*const sq6=()=>*/
'\r\n<style type="text/css">\r\n'+
	'.rect1, .polygon1 {stroke: blue;}\r\n'+
	'.txt1 {font-family: Arial; font-size: 12px; line-height: 0; fill:white;}\r\n'+
	'textPath {font-family: sans-serif; font-size: 16px;}\r\n'+
	'</style>\r\n'+
	'<rect class="x" x="0" y="0" width="'+s700+'" height="'+hey+'" fill="#ded" />\r\n';
	
const bab=x=>((' '+ss+' ')[x]==='('&&(' '+ss+' ')[x+2]===')');// один в кольце

//******** преотрисовка ... графические примитивы
const recta0=(axe,x1,y1,x2,y2,nom)=>{
		svg.innerHTML+=qq7(axe,off+x1,y1,x2,y2,nom);//break;//rect	
	}
const recta1=(axe,x1,y1,x2,y2,nom)=>{
		svg.innerHTML+=qq8(axe,off+x1,y1,x2,y2);//ul	
	}
const recta2=(axe,x1,y1,x2,y2,nom)=>{
		svg.innerHTML+=qq9(axe,off+x1,y1,x2,y2);//li	
	}	
	

const trg3=(axe,x1,y1,nom='error',ink='red')=>{
	svg.innerHTML+=qq3(axe,off+x1,y1,nom,ink);// полигон
	}

const rng=(axe,x1,y1,x2,nom='')=>{
	svg.innerHTML+=sq2(axe,off+x1,y1,x2,nom);// эллипс
	}
//*******************


 
let axe=1.0;
let stek3=[]; // квадраты и труги, кольца...порядок рисования
//******************************
let ss=s;
const u={
	'0':{x:dx,y:0,},
	'a':{x:0,y:dy,},	
	'1':{x:dx/2|0,y:dy,},
	'2':{x:0,y:dy,},
	'3':{x:dx,y:0,},
	'4':{x:dx,y:0,},	
	'-':{x:dx/2|0,y:0,},
	'(':{x:dx/2|0,y:dy,},//
	')':{x:dx/2|0,y:-dy,},//
	'[':{x:dx/2|0,y:dy,},
	']':{x:dx/2|0,y:-dy,},
	'z':{x:0,y:-dy,},	
	};
let x1x=x11x,y1y=y11y;// точка отсчета


let j=0;
let r=1;
let stk=[]; // 
let count=-1;



//*******

let v2;
tv3.forEach((n,i)=>{
	switch (n[0]){
		case '(': axe=2.4;stk.push({x:x1x,y:y1y}); break;	
		case ')': axe=2.4;v2=stk.pop(); stek3.push({
				x1:v2.x,
				y1:v2.y,
				x2:x1x-v2.x+u[n[0]].x,
				m:'(',
				axe: axe,
				nom: n[1],
				});
			break;
		case '[': axe=0.5;stk.push({x:x1x,y:y1y});break
		case ']': axe=0.5;v2=stk.pop();
			stek3.push({
				x1:v2.x,
				y1:v2.y,
				x2:x1x-v2.x+u[n[0]].x,
				m:'[',
				axe: axe,
				nom: n[1],
				});
			break;	////
		case '1': axe=1.0;stk.push({x:x1x,y:y1y-dy,m:n[0],axe:axe,});break;			
		case '2': axe=0.5;stk.push({x:x1x,y:y1y-dy,m:n[0],axe:axe,});break;			
		case 'a': axe=1.5;stk.push({x:x1x,y:y1y-dy,m:n[0],axe:axe,});break;			
		case 'z':  v2=stk.pop();axe=v2.axe;
			if (!v2) break;// стек исчерпался
			{stek3.push({
				x1:v2.x,
				y1:(v2.y+dy),
				x2:(x1x-u[n[0]].x)-v2.x,
				y2:-dy,
				m:v2.m,
				axe:axe,
				nom:n[1],
				});
			}
			break;
		case '0':axe=1.5;stek3.push({
					x1:x1x,
					y1:y1y,
					m:'0',
					axe: axe,
					nom: n[1],
					ink: 'lime',
					}); 
				break;
		case '3':axe=3.0;stek3.push({
					x1:x1x,
					y1:y1y,
					m:n[0],
					axe: axe,
					nom: n[1],
					ink:'black',
					});
				break;
		case '4':axe=2.0;stek3.push({
					x1:x1x,
					y1:y1y,
					m:n[0],
					axe: axe,
					nom: n[1],
					ink:'purple',
					});
				break;				
				
	}//switch
	if(u.hasOwnProperty(n[0])){//
		x1x+=u[n[0]].x;
		y1y+=u[n[0]].y*axe;//
		}
});

//console.table(stek3);
//*******************

off=(s700-x1x)/2;// смещение композиции
{// стекер-3 ☯

//console.table(stek3);

stek3=stek3.sort((a,b)=>b.y1-a.y1); //сортировка точечная нотация
stek3.forEach((x,j)=>{
	switch (x.m){
		//блоки
		case '(': {rng(x.axe,x.x1,x.y1,x.x2,x.nom); break}
		case '[': {rng(x.axe,x.x1,x.y1,x.x2,); break}	//	
	}//switch
});//forEach 
stek3.forEach((x,j)=>{
	switch (x.m){
		//блоки		/////	
		case '1': recta1(x.axe,x.x1,x.y1,x.x2,x.y2,x.nom);break;
		case '2': recta2(x.axe,x.x1,x.y1,x.x2,x.y2,x.nom);break;
		case 'a': recta0(x.axe,x.x1,x.y1,x.x2,x.y2,x.nom);break;
		//элементы
		case '0':  
		case '3': 
		case '4': trg3(x.axe,x.x1,x.y1,x.nom,x.ink); break;
	}//switch
});//forEach  
}


stek4.sort((a,b)=>-1)// реверс
	.forEach(x=>{svg.innerHTML+=sq0(x.axe,x.x1,x.y1,x.x2,x.nom)});// драпировка в обратном порядке



const ck=document.querySelectorAll('#svg .x'); // смена цвета
ck.forEach(x=>{
	x.addEventListener('click',(e)=>{
		e.target.setAttribute('fill',mainColor);	
		})	
	});
	
const mk=document.querySelectorAll('#svg textPath');  // смена текста
mk.forEach(x=>{
	x.addEventListener('click',(e)=>{
		e.target.setAttribute('fill','black');
		e.target.innerHTML=prompt(e.target.innerHTML)||e.target.innerHTML;	//'5454545';//
		})	
	});	

}//main
//*****************************************************************//
const cpy=x=>{ // копирование в буфер обмена
	const cop=document.querySelector('#cop');
	cop.value='<svg width="'+s700+'" height="'+hey+'" viewBox="0 0 '+s700+' '+hey+'" fill="none">';
	cop.value+=svg.innerHTML;// пугает /rect да и хрен на него
	cop.value+='</svg>';
	cop.select();
	document.execCommand('copy');
} 

//*********************************  отрисовка
const sq2=(axe,x,y,w,nom)=>{// кольцо (+драпировка)
	let yy=y+axe*dy; // вершина знакоместа	
	stek4.unshift({x1:x,y1:y,x2:x+w,axe:axe,nom:nom});// единственный источник заполнения stek4	
	let f='';
	f+='<ellipse class="x" \r\n'+
	'     cx="'+(x+(w/2)).toFixed(1)+'" \r\n'+
	'     cy="'+(yy-10).toFixed(1)+'" \r\n'+
	'     rx="'+(w/2).toFixed(1)+'" \r\n'+
	'     ry="10" \r\n'+
	'     stroke="blue" \r\n'+
	'     fill="cyan" \r\n'+
	'	  opacity="1"\r\n'+
	'     stroke-width="1"/>\r\n';
	return f;
	}


const qq3=(axe,x,y,nom,ink='red')=>// треуг особый
	{
	ee++;
	let yy=y+axe*dy;// вершина знакоместа
	let xx=x+dx/2|0;
	return '<polygon\r\n '+
	'	class="rect1 x" \r\n'+
	'	points="'+x+' '+y+' '+(xx)+' '+(yy).toFixed(1)+' '+(x+dx)+' '+y+'" \r\n'+
	'	opacity="'+city+'"\r\n'+
	'	fill="'+ink+'" />\r\n'+//#198754
	'	<defs><path id="tp'+ee+'" d="M'+(xx)+','+(yy-3).toFixed(1)+' '+ (xx+250)+','+(yy-253).toFixed(1)+'"></path></defs>'+
	'	<use xlink:href="#tp'+ee+'"></use>'+	
	'	<text x="0" y="0" fill="navy"><textPath xlink:href="#tp'+ee+'">'+
	nom+
	'	</textPath></text>\r\n';
	}




/*
const sq6=()=>'\r\n<style type="text/css">\r\n'+
	'.rect1, .polygon1 {stroke: blue;}\r\n'+
	'.txt1 {font-family: Arial; font-size: 12px; line-height: 0; fill:white;}\r\n'+
	'textPath {font-family: sans-serif; font-size: 16px;}\r\n'+
	'</style>\r\n'+
	'<rect class="x" x="0" y="0" width="'+s700+'" height="'+hey+'" fill="#ded" />\r\n';
*/

const qq7=(axe,x,y,w,h,nom)=>// квадрат который не спит на спине
	{
	ee++;
	let yy=y+axe*dy;
	return '<rect \r\n'+
	'	class="rect1 x" \r\n'+
	'	x="'+x+'" \r\n'+
	'	y="'+(yy).toFixed(1)+'" \r\n'+
	'	width="'+w+'" \r\n'+
	'	height="'+(axe*h).toFixed(1)+'" \r\n'+
	'	opacity="'+city+'"\r\n'+
	'	fill="gold" />\r\n'+
	'	<defs><path id="tp'+ee+'" d="M'+(x+w+10)+','+(yy-10).toFixed(1)+' '+ (x+w+260)+','+(yy-260).toFixed(1)+'"></path></defs>'+
	'	<use xlink:href="#tp'+ee+'"></use>'+	
	'	<text x="0" y="0" fill="navy"><textPath xlink:href="#tp'+ee+'">'+
	nom+
	'	</textPath></text>\r\n';
	}




const qq8=(axe,x,y,w,h)=>// список ul  
	{
	ee++;
	let yy=y+axe*dy;
	return '<polygon \r\n'+
	'	class="rect1 x" \r\n'+
	'	points="'+x+' '+(y)+' '+(x+(dx*0.4)|0).toFixed(1)+' '+(yy).toFixed(1)+
	' '+(x+w)+' '+(yy).toFixed(1)+' '+(x+w)+' '+(y)+'" \r\n'+
	'	opacity="'+city+'"\r\n'+
	'	fill="gold" />\r\n'+//#ffc107
	'	<defs><path id="tp'+ee+'" d="M'+(x+w+10)+','+(yy-0).toFixed(1)+' '+ (x+w+260)+','+(yy-250).toFixed(1)+'"></path></defs>'+
	'	<use xlink:href="#tp'+ee+'"></use>'+	
	'	<text x="0" y="0" fill="navy"><textPath xlink:href="#tp'+ee+'">'+
	'	ul'+
	'	</textPath></text>\r\n';
	}


const qq9=(axe,x,y,w,h)=>// список li  
	{
	ee++;
	let yy=y+axe*dy;
	return '<polygon  \r\n'+
	'	class="rect1 x" \r\n'+
	'	points="'+(x-(dx*0.1)|0).toFixed(1)+' '+(y)+' '+x+' '+(yy).toFixed(1)+' '+(x+w)+' '+(yy).toFixed(1)+' '+(x+w)+' '+(y)+'" \r\n'+
	'	opacity="'+city+'"\r\n'+
	'	fill="purple" />\r\n'+//#ffc107
	'	<defs><path id="tp'+ee+'" d="M'+(x+w+10)+','+(yy).toFixed(1)+' '+ (x+w+260)+','+(yy-250).toFixed(1)+'"></path></defs>'+
	'	<use xlink:href="#tp'+ee+'"></use>'+	
	'	<text x="0" y="0" fill="navy"><textPath xlink:href="#tp'+ee+'">'+
	'	li'+
	'	</textPath></text>\r\n';
	}
	 
function sq0(axe,x1,y1,x2,nom)// рюмашка (рисуем с 4-ого стека) единичный означает парение
	{
    ee++;
	const i=(x2-x1)/6;	
	let k=0.5;
	if(axe<=1)// парящий от летящего отличается масштабом
	return '<path '+
	'class="rect1 x" '+ 
	'd="M'+(x1+3*i).toFixed(1)+' '+(y1+dy*k*k*k).toFixed(1)+' '+
	'C'+(x1+i)+' '+(y1+dy*k*k*k).toFixed(1)+' '+(x1-i*k).toFixed(1)+' '+(y1+dy*k).toFixed(1)+' '+
	(x1).toFixed(1)+' '+(y1+dy*axe-10).toFixed(1)+' '+
	'C'+(x1+i).toFixed(1)+' '+(y1+0+dy*axe).toFixed(1)+' '+(x1+2*i).toFixed(1)+' '+(y1+dy*axe).toFixed(1)+' '+	
((x2+x1)/2).toFixed(1)+' '+(y1+dy*axe).toFixed(1)+' '+	
	'C'+(x2-2*i).toFixed(1)+' '+(y1+dy*axe).toFixed(1)+' '+(x2-i).toFixed(1)+' '+(y1+0+dy*axe).toFixed(1)+' '+
	(x2).toFixed(1)+' '+(y1+dy*axe-10).toFixed(1)+' '+
	'C'+(x2+i*k)+' '+(y1+dy*k).toFixed(1)+' '+(x2-i).toFixed(1)+' '+(y1+dy*k*k*k).toFixed(1)+' '+
	(x2-3*i).toFixed(1)+' '+(y1+dy*k*k*k).toFixed(1)+' z" '+ 
	'opacity="'+city+'" '+
	'stroke="none" '+
	'fill="white" />\r\n'
	else
	return '<path '+
	'class="rect1 x" '+
	'd="M'+(x1+2*i).toFixed(1)+' '+(y1)+' '+
	'C'+(x1+dx)+' '+(y1+dy).toFixed(1)+' '+(x1-i).toFixed(1)+' '+(y1+dy).toFixed(1)+' '+
	(x1)+' '+(y1+dy*axe-10).toFixed(1)+' '+
	'C'+(x1+i).toFixed(1)+' '+(y1+0+dy*axe).toFixed(1)+' '+(x1+2*i).toFixed(1)+' '+(y1+dy*axe-0).toFixed(1)+' '+
((x2+x1)/2).toFixed(1)+' '+(y1+dy*axe).toFixed(1)+' '+
	'C'+(x2-2*i).toFixed(1)+' '+(y1+dy*axe-0).toFixed(1)+' '+(x2-i).toFixed(1)+' '+(y1+0+dy*axe).toFixed(1)+' '+
	(x2).toFixed(1)+' '+(y1+dy*axe-10).toFixed(1)+' '+
	'C'+(x2+i)+' '+(y1+dy).toFixed(1)+' '+(x2-dx).toFixed(1)+' '+(y1+dy).toFixed(1)+' '+	
	(x2-2*i).toFixed(1)+' '+(y1).toFixed(1)+'z" '+  
	'opacity="'+city+'" '+
	'fill="yellow" />\r\n'
	+ 
'<defs><path id="tp'+(ee)+'" d="M'+(x2+10)+','+(y1-11+dy*axe-10).toFixed(1)+
' '+(x2+260)+','+(y1-260+dy*axe-10).toFixed(1)+'"></path></defs>'+
'<use xlink:href="#tp'+(ee)+'"></use>'+	
'<text x="0" y="0" fill="navy"><textPath xlink:href="#tp'+(ee)+'">'+
(nom)+
'</textPath></text>';	
 } 

 main();//.toFixed(1)
 
 
// 
selen.onchange(); // выбранная формула юзается для постройки пиалы
</script>
</body>
</html>
